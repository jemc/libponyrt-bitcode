This patch updates the Pony garbage collector to store the type descriptor
for sent objects in the object map, instead of relying on the object itself
always holding a type descriptor as its initial implicit field.

This change makes the object map entries take up 25% more memory, but it allows
us to make other changes in the Savi language implementation that remove the
type descriptor from most objects, and avoid heap-allocating for "boxed"
stack value types, so the net result is that we should save more memory overall.

However, since the Pony language implementation does not have these advantages,
introducing this object map change upstream would be a bad trade-off for Pony.
So, we keep it here and apply it in a patch.

This patch in and of itself is not strictly incompatible with the Pony language,
it would just be a performance regression if adopted there. Howeve, the Savi
language relies on this patch being in place, and not having it would cause
segmentation faults because the expected type descriptors would not be there
in the objects that the garbage collector would be trying to mark.

---

diff --git a/src/libponyrt/gc/actormap.c b/src/libponyrt/gc/actormap.c
index 24be653a..fdb110a2 100644
--- a/src/libponyrt/gc/actormap.c
+++ b/src/libponyrt/gc/actormap.c
@@ -38,7 +38,8 @@ object_t* ponyint_actorref_getobject(actorref_t* aref, void* address)
 object_t* ponyint_actorref_getorput(actorref_t* aref, void* address,
   uint32_t mark)
 {
-  return ponyint_objectmap_getorput(&aref->map, address, mark);
+  pony_type_t* type = *(pony_type_t**)address;
+  return ponyint_objectmap_getorput(&aref->map, address, type, mark);
 }
 
 void ponyint_actorref_free(actorref_t* aref)
diff --git a/src/libponyrt/gc/gc.c b/src/libponyrt/gc/gc.c
index 680c04af..96741a96 100644
--- a/src/libponyrt/gc/gc.c
+++ b/src/libponyrt/gc/gc.c
@@ -139,7 +139,7 @@ static void send_local_object(pony_ctx_t* ctx, void* p, pony_type_t* t,
   int mutability)
 {
   gc_t* gc = ponyint_actor_gc(ctx->current);
-  object_t* obj = ponyint_objectmap_getorput(&gc->local, p, gc->mark);
+  object_t* obj = ponyint_objectmap_getorput(&gc->local, p, t, gc->mark);
 
   if(obj->mark == gc->mark)
     return;
@@ -209,7 +209,7 @@ static void acquire_local_object(pony_ctx_t* ctx, void* p, pony_type_t* t,
   int mutability)
 {
   gc_t* gc = ponyint_actor_gc(ctx->current);
-  object_t* obj = ponyint_objectmap_getorput(&gc->local, p, gc->mark);
+  object_t* obj = ponyint_objectmap_getorput(&gc->local, p, t, gc->mark);
 
   if(obj->mark == gc->mark)
     return;
@@ -651,7 +651,7 @@ void ponyint_gc_markimmutable(pony_ctx_t* ctx, gc_t* gc)
       // Mark in our heap and recurse if it wasn't already marked.
       void* p = obj->address;
       chunk_t* chunk = ponyint_pagemap_get(p);
-      pony_type_t* type = *(pony_type_t**)p;
+      pony_type_t* type = obj->type;
       mark_local_object(ctx, chunk, p, type, PONY_TRACE_IMMUTABLE);
     }
   }
@@ -726,7 +726,7 @@ bool ponyint_gc_acquire(gc_t* gc, actorref_t* aref)
     // Add to our RC. The object may not be in our object map, if it was
     // reached through another immutable reference.
     object_t* obj_local = ponyint_objectmap_getorput(&gc->local, obj->address,
-      gc->mark);
+      obj->type, gc->mark);
     obj_local->rc += obj->rc;
 
     // Mark as immutable if necessary.
diff --git a/src/libponyrt/gc/objectmap.c b/src/libponyrt/gc/objectmap.c
index dbfe4248..70f41c17 100644
--- a/src/libponyrt/gc/objectmap.c
+++ b/src/libponyrt/gc/objectmap.c
@@ -16,10 +16,11 @@ static bool object_cmp(object_t* a, object_t* b)
   return a->address == b->address;
 }
 
-static object_t* object_alloc(void* address, uint32_t mark)
+static object_t* object_alloc(void* address, pony_type_t* type, uint32_t mark)
 {
   object_t* obj = (object_t*)POOL_ALLOC(object_t);
   obj->address = address;
+  obj->type = type;
   obj->rc = 0;
   obj->immutable = false;
 
@@ -45,7 +46,7 @@ object_t* ponyint_objectmap_getobject(objectmap_t* map, void* address, size_t* i
 }
 
 object_t* ponyint_objectmap_getorput(objectmap_t* map, void* address,
-  uint32_t mark)
+  pony_type_t* type, uint32_t mark)
 {
   size_t index = HASHMAP_UNKNOWN;
   object_t* obj = ponyint_objectmap_getobject(map, address, &index);
@@ -53,7 +54,7 @@ object_t* ponyint_objectmap_getorput(objectmap_t* map, void* address,
   if(obj != NULL)
     return obj;
 
-  obj = object_alloc(address, mark);
+  obj = object_alloc(address, type, mark);
   ponyint_objectmap_putindex(map, obj, index);
   return obj;
 }
diff --git a/src/libponyrt/gc/objectmap.h b/src/libponyrt/gc/objectmap.h
index 6d636abe..6164f1c5 100644
--- a/src/libponyrt/gc/objectmap.h
+++ b/src/libponyrt/gc/objectmap.h
@@ -10,6 +10,7 @@ typedef struct object_t
 {
   void* address;
   size_t rc;
+  pony_type_t* type;
   uint32_t mark;
   bool immutable;
 } object_t;
@@ -19,7 +20,7 @@ DECLARE_HASHMAP(ponyint_objectmap, objectmap_t, object_t);
 object_t* ponyint_objectmap_getobject(objectmap_t* map, void* address, size_t* index);
 
 object_t* ponyint_objectmap_getorput(objectmap_t* map, void* address,
-  uint32_t mark);
+  pony_type_t* type, uint32_t mark);
 
 void ponyint_objectmap_sweep(objectmap_t* map);
 
